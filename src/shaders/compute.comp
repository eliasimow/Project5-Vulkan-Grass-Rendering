#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32


// ------------------------------------------------------------
// 3D Simplex Noise (GLSL 450) - compatible with Vulkan
// Adapted from Ashima Arts / Stefan Gustavson
// ------------------------------------------------------------

vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }

vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }

vec4 taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

// ------------------------------------------------------------
// 3D Simplex Noise
// ------------------------------------------------------------
float snoise(vec3 v)
{
    const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);

    // First corner
    vec3 i  = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);

    // Other corners
    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    // Offsets for remaining corners
    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - 0.5;

    // Permutations
    i = mod289(i);
    vec4 p = permute(
                 permute(
                     permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))
                     + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                 + i.x + vec4(0.0, i1.x, i2.x, 1.0)
             );

    // Gradients: mapped onto an octahedron
    vec4 j = p - 49.0 * floor(p / 49.0);

    vec4 x_ = floor(j / 7.0);
    vec4 y_ = floor(j - 7.0 * x_); // mod(j,7)

    vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;
    vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);

    vec4 s0 = floor(b0) * 2.0 + 1.0;
    vec4 s1 = floor(b1) * 2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;

    vec3 g0 = vec3(a0.xy, h.x);
    vec3 g1 = vec3(a0.zw, h.y);
    vec3 g2 = vec3(a1.xy, h.z);
    vec3 g3 = vec3(a1.zw, h.w);

    // Normalize gradients
    vec4 norm = taylorInvSqrt(vec4(
        dot(g0, g0),
        dot(g1, g1),
        dot(g2, g2),
        dot(g3, g3)
    ));
    g0 *= norm.x;
    g1 *= norm.y;
    g2 *= norm.z;
    g3 *= norm.w;

    // Mix final noise value
    vec4 m = max(0.6 - vec4(
        dot(x0, x0),
        dot(x1, x1),
        dot(x2, x2),
        dot(x3, x3)
    ), 0.0);
    m = m * m;
    m = m * m;

    vec4 px = vec4(
        dot(x0, g0),
        dot(x1, g1),
        dot(x2, g2),
        dot(x3, g3)
    );

    return 42.0 * dot(m, px);
}



layout(local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform CameraBufferObject {
    mat4 view;
    mat4 proj;
    vec4 pos;
} camera;

layout(set = 1, binding = 0) uniform Time {
    float deltaTime;
    float totalTime;
};

struct Blade {
    vec4 v0;
    vec4 v1;
    vec4 v2;
    vec4 up;
};

layout (set = 2, binding = 0) buffer InBlades {
    Blade[] inBlades;
};

layout (set = 2, binding = 1) buffer OutBlades {
    Blade[] outBlades;
};

layout(set = 2, binding = 2) buffer NumBlades {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint firstInstance;
} numBlades;

bool inBounds(float value, float bounds) {
    return (value >= -bounds) && (value <= bounds);
}

float MASS = 1.0;

void main() {
    // Reset the number of blades to 0
    if (gl_GlobalInvocationID.x == 0) {
         numBlades.vertexCount = 0u;
    }
    barrier(); // Wait till all threads reach this point

    // Read the blade for this invocation
    uint idx = gl_GlobalInvocationID.x;
    Blade blade = inBlades[idx];

    // Forces
    vec3 gravityDirection = vec3(0.0, -1.0, 0.0);
    float gravityStrength = 9.81;
    vec3 environmentGravity = normalize(gravityDirection) * gravityStrength;

    vec3 front = cross(blade.up.xyz, vec3(cos(blade.v0.w), 0.0, sin(blade.v0.w)));
    vec3 frontGravity = 0.25 * gravityStrength * front;
    vec3 totalGravity = frontGravity + environmentGravity;


    vec3 initialPosition = (blade.v0.xyz + blade.v1.w * blade.up.xyz);
    
    vec3 recovery = (initialPosition - blade.v2.xyz) * blade.up.w;
    
    //wind:
    
    vec3 windDirection = normalize(vec3(1.0, 0.0, 1.0));
    float windMagnitude = 2.0;
    vec3 windForce = windDirection * snoise(blade.v2.xyz * 0.1 + windDirection * totalTime) * windMagnitude;
    windForce  *= 1.0 - dot(normalize(windForce), (blade.v2.xyz - blade.v0.xyz) / (blade.v2.xyz - blade.v0.xyz).length());

    vec3 totalForce = totalGravity + recovery + windForce;
    vec3 acceleration = totalForce / MASS;

    // Top vertex update (vec3)
    vec3 newTop = blade.v2.xyz + acceleration * deltaTime;

    // constraint 1: stay above ground
    // use dot for projection (was previously using component-wise *)
    float proj = dot(blade.up.xyz, (newTop - blade.v0.xyz));
    float clampProj = min(proj, 0.0); // clamp to <= 0.0
    newTop = newTop - blade.up.xyz * clampProj;

    float lProj = length(newTop - blade.v0.xyz - blade.up.xyz * dot(newTop - blade.v0.xyz, blade.up.xyz));

    // compute newControl using vec3 components (was mixing vec4 and vec3)
    float v1w = blade.v1.w;
    float factor = max(1.0 - lProj / v1w, 0.05 * max(lProj / v1w, 1.0));
    vec3 newControl = blade.v0.xyz + v1w * blade.up.xyz * factor;

    float l0 = length(newTop - blade.v0.xyz);
    float l1 = length(newControl - blade.v0.xyz) + length(newTop - newControl);

    // degree 2
    float len  = (2.0 * l0 + l1) / 3.0;
    float r = v1w / len;

    vec3 v1Correction = blade.v0.xyz + (newControl - blade.v0.xyz) * r;
    vec3 v2Correction = v1Correction + (newTop - v1Correction) * r;

    blade.v1 = vec4(v1Correction, blade.v1.w);
    blade.v2 = vec4(v2Correction, blade.v2.w);

   // blade.v1 = vec4(newControl, blade.v1.w);
  //  blade.v2 = vec4(newTop, blade.v2.w);





    // Write updated blade back to input buffer (if intended)
    inBlades[idx] = blade;


    vec3 cameraDirection = vec3(camera.view[0][2], camera.view[1][2], camera.view[2][2]);
    vec3 bladeDirection = vec3(cos(blade.v0.w), 0.0, sin(blade.v0.w));
  
    if (abs(dot(cameraDirection, bladeDirection)) > 0.8) {
            return;
    }

    vec3 m = 0.25 * blade.v0.xyz + 0.5 * blade.v1.xyz + 0.25 * blade.v2.xyz;
    vec4 clip = camera.proj * camera.view * vec4(m, 1.f);
    float limit = clip.w + 0.05;
    if (clip.x < -limit || clip.x > limit || clip.y < -limit || clip.y > limit || clip.z < -limit || clip.z > limit) {
            return;
    }

    float dProj = length(blade.v0.xyz - camera.pos.xyz - blade.up.xyz * dot(blade.v0.xyz - camera.pos.xyz, blade.up.xyz));
    if (gl_GlobalInvocationID.x % 10 > floor(10 * (1 - dProj / 5.0))) {
            return;
    }

    // Cull/write visible blades with atomic increment
    uint outBladeId = atomicAdd(numBlades.vertexCount, 1u);
    outBlades[outBladeId] = blade;
}
